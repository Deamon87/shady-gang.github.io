[{"id":0,"href":"/how/","title":"How this works","section":"Index","content":" What is Shady # Vcc is little more than a front-end for Shady, a compiler and IR resulting of years of research and development at Saarland University. Shady was initially started to rationalise our GPU backends by supporting Vulkan in AnyDSL\nYou can think of Shady as implementing a futuristic dialect of SPIR-V that corresponds to our wishlist of features. Shady is free software and we\u0026rsquo;de love to have other front-ends use it ! We are currently working towards publishing papers on the internals of shady and we will be updating this website with more detail once we do.\nRelationship to Clang and LLVM # Vcc is a wrapper for the clang driver and directs it to emit the LLVM IR for your source files. LLVM is not involved in any optimisations on the code, instead Shady parses the LLVM IR and runs it\u0026rsquo;s set of optimisation and legalisation passes to turn the IR into something that can run on Vulkan. Finally, Shady emits SPIR-V code that you application can then use.\nVcc does not use a fork of LLVM nor Clang. It needs to link against LLVM to use it\u0026rsquo;s bitcode parser and C API, but any recent version of LLVM should work. Shady supportts both typed and untyped pointers so a large range of LLVM versions should work with it.\nExposing SPIR-V/Vulkan as C/C++ language extensions # Since we are not modifying Clang, we had to find a way to add our own intrinsics to expose features not present in standard C/C++, such as fixed-function texturing support. This is done through the general-purpose __attribute__((annotate(\u0026quot;\u0026quot;)) annotations, which are thankfully retained in the IR. Shady comes with a \u0026lt;shady.h\u0026gt; header that you can simply include in your application to use the extra features. You can look at the Vcc tests and samples for guidance on how to use these.\nSome features are currently not exposed, but that doesn\u0026rsquo;t mean that Vcc/Shady cannot easily support them. As we are developing this we are constantly exposing new extensions, sometimes it is just a matter of adding appropriate intrinsics. Feel free to raise issues on GitHub if there is something you\u0026rsquo;d like to see.\n"},{"id":1,"href":"/use/","title":"Using Vcc","section":"Index","content":" Getting a copy of Vcc # There currently are no release builds available for Vcc, however it can be compiled as part of Shady which is freely available on GitHub. The following dependencies are required:\nA C11 compliant compiler CMake 3.13 or later json-c SPIRV-Headers Vulkan-Headers are optional but are used to build some components of shady such as tests A copy of LLVM that includes the CMakeConfig.cmake files, so that Vcc can link against it Multiple LLVM versions are supported because we use LLVM-C, which has a more stable interface. Versions 14 to 17 have been tested so far. Additionally, a copy of clang on your path is required at runtime for vcc to operate. This copy may be a different version than the LLVM you linked Vcc against, however might cause issues due to how the LLVM IR evolves over time.\nUsing Vcc # Vcc is used much like GCC or Clang is. In fact, most arguments are just forwarded to Clang! Using vcc --help one can a list of vcc specific arguments and flags. Vcc can produce SPIR-V binary files, and also has experimental support for GLSL and ISPC output. These SPIR-V files can then be ingested by your application as normal.\nUsing \u0026lt;shady.h\u0026gt; # The \u0026lt;shady.h\u0026gt; header includes definitions for intrinsics and macros that are unique to shaders and not exposed in the C/C++ standard librairies.\nRequired Vulkan version and capabilities # Vcc currently requires Vulkan 1.1 and support for VK_KHR_buffer_device_address. It also currently requires support for `IWe are still working on organising the compiler flags and we will be writing up a more comprehensive support matrix later.\n"},{"id":2,"href":"/why/","title":"Why ?","section":"Index","content":"This is a lot of effort. Why are we chosing to research this topic ?\nDissatisfaction with \u0026ldquo;Legacy\u0026rdquo; Shading Languages # API Fragmentation # People familiar with the GPU world know there are two kinds of GPU APIs: compute and graphics. CUDA, ROCm and OpenCL are filed as the former, while Vulkan, DirectX and OpenGL would be the latter.\nOn the surface it would seem that graphics APIs and compute APIs overlap - both let you program the GPU, and in fact modern graphics APIs offer \u0026ldquo;compute shaders\u0026rdquo;\nWorking Towards Single-source GPU programming # "}]